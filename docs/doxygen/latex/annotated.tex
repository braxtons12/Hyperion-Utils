\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1ChangeDetector}{hyperion\+::utils\+::\+Change\+Detector$<$ T $>$}} \\*Stores a value and detects if an updated value is different than the previous one }{\pageref{classhyperion_1_1utils_1_1ChangeDetector}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer_1_1ConstIterator}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Thread\+Safety, Allocator $>$\+::\+Const\+Iterator}} \\*Read-\/only Random-\/\+Access Bidirectional iterator for {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer}{Ring\+Buffer}}} }{\pageref{classhyperion_1_1utils_1_1RingBuffer_1_1ConstIterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1ConstIterator}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Ring\+Buffer\+Type\+::\+Thread\+Safe, Allocator $>$\+::\+Const\+Iterator}} \\*Read-\/only Random-\/\+Access Bidirectional iterator for {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer}{Ring\+Buffer}}} }{\pageref{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1ConstIterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1Element}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Ring\+Buffer\+Type\+::\+Thread\+Safe, Allocator $>$\+::\+Element}} }{\pageref{structhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1Element}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Error}{hyperion\+::utils\+::\+Error}} \\*Base error interface. Used to implement custom error types used as the {\ttfamily E} in {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1Result}{Result}}$<$T, E$>$} to represent and communicate failure of a function }{\pageref{classhyperion_1_1utils_1_1Error}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1ErrorWrapper}{hyperion\+::utils\+::\+Error\+Wrapper$<$ E $>$}} }{\pageref{structhyperion_1_1utils_1_1ErrorWrapper}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1type__traits_1_1has__not__equal}{hyperion\+::utils\+::type\+\_\+traits\+::has\+\_\+not\+\_\+equal$<$ T, U, typename $>$}} \\*Type Trait to determine if {\ttfamily T} has the {\ttfamily !=} operator comparing to type {\ttfamily U}, where {\ttfamily U} defaults to {\ttfamily T} }{\pageref{structhyperion_1_1utils_1_1type__traits_1_1has__not__equal}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1type__traits_1_1has__not__equal_3_01T_00_01U_00_01std_1_1void__t_3_01e94a99caaeb976a8479ad9fc45e7a904}{hyperion\+::utils\+::type\+\_\+traits\+::has\+\_\+not\+\_\+equal$<$ T, U, std\+::void\+\_\+t$<$ decltype(std\+::declval$<$ T $>$() !=std\+::declval$<$ U $>$())$>$ $>$}} \\*Type Trait to determine if {\ttfamily T} has the {\ttfamily !=} operator comparing to type {\ttfamily U}, where {\ttfamily U} defaults to {\ttfamily T} }{\pageref{structhyperion_1_1utils_1_1type__traits_1_1has__not__equal_3_01T_00_01U_00_01std_1_1void__t_3_01e94a99caaeb976a8479ad9fc45e7a904}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1type__traits_1_1is__copy__move__or__pointer}{hyperion\+::utils\+::type\+\_\+traits\+::is\+\_\+copy\+\_\+move\+\_\+or\+\_\+pointer$<$ T $>$}} \\*Type Trait to determine if {\ttfamily T} is copyable, movable, or a pointer type }{\pageref{structhyperion_1_1utils_1_1type__traits_1_1is__copy__move__or__pointer}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1type__traits_1_1is__copy__or__move}{hyperion\+::utils\+::type\+\_\+traits\+::is\+\_\+copy\+\_\+or\+\_\+move$<$ T $>$}} \\*Type Trait to determine if {\ttfamily T} is copyable or movable }{\pageref{structhyperion_1_1utils_1_1type__traits_1_1is__copy__or__move}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1is__error__code__enum_3_01hyperion_1_1utils_1_1LockFreeQueueErrorType_01_4}{std\+::is\+\_\+error\+\_\+code\+\_\+enum$<$ hyperion\+::utils\+::\+Lock\+Free\+Queue\+Error\+Type $>$}} }{\pageref{structstd_1_1is__error__code__enum_3_01hyperion_1_1utils_1_1LockFreeQueueErrorType_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structstd_1_1is__error__code__enum_3_01hyperion_1_1utils_1_1LogErrorType_01_4}{std\+::is\+\_\+error\+\_\+code\+\_\+enum$<$ hyperion\+::utils\+::\+Log\+Error\+Type $>$}} }{\pageref{structstd_1_1is__error__code__enum_3_01hyperion_1_1utils_1_1LogErrorType_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer_1_1Iterator}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Thread\+Safety, Allocator $>$\+::\+Iterator}} \\*Random-\/\+Access Bidirectional iterator for {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer}{Ring\+Buffer}}} }{\pageref{classhyperion_1_1utils_1_1RingBuffer_1_1Iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1Iterator}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Ring\+Buffer\+Type\+::\+Thread\+Safe, Allocator $>$\+::\+Iterator}} \\*Random-\/\+Access Bidirectional iterator for {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer}{Ring\+Buffer}}} }{\pageref{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4_1_1Iterator}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1detail_1_1literal__parser}{hyperion\+::detail\+::literal\+\_\+parser$<$ Sum, Chars $>$}} }{\pageref{structhyperion_1_1detail_1_1literal__parser}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1detail_1_1literal__parser_3_01Sum_01_4}{hyperion\+::detail\+::literal\+\_\+parser$<$ Sum $>$}} }{\pageref{structhyperion_1_1detail_1_1literal__parser_3_01Sum_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1LockFreeQueue}{hyperion\+::utils\+::\+Lock\+Free\+Queue$<$ T, Policy, Capacity $>$}} }{\pageref{classhyperion_1_1utils_1_1LockFreeQueue}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1LockFreeQueueError}{hyperion\+::utils\+::\+Lock\+Free\+Queue\+Error}} \\*{\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1Error}{Error}}} type for communicating queueing errors {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1Error}{Error}}}s can occur if an entry fails to queue due to queueing policy or an entry can\textquotesingle{}t be read because the queue is empty }{\pageref{classhyperion_1_1utils_1_1LockFreeQueueError}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1LockFreeQueueErrorCategory}{hyperion\+::utils\+::\+Lock\+Free\+Queue\+Error\+Category}} \\*{\ttfamily std\+::error\+\_\+category} type for {\ttfamily Lock\+Free\+Queue\+Error\+Type}s. Provides error catgory functionality for {\ttfamily Lock\+Free\+Queue\+Error\+Type}s }{\pageref{structhyperion_1_1utils_1_1LockFreeQueueErrorCategory}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Logger}{hyperion\+::utils\+::\+Logger$<$ Log\+Parameters $>$}} \\*Hyperion logging type for formatted logging. Uses fmtlib/fmt for entry formatting and stylizing }{\pageref{classhyperion_1_1utils_1_1Logger}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1LoggerError}{hyperion\+::utils\+::\+Logger\+Error}} \\*\mbox{\hyperlink{classhyperion_1_1utils_1_1Error}{Error}} type for communicating logger errors Errors can occur when an entry fails to be queued or an entry is passed in at an invalid logging level }{\pageref{classhyperion_1_1utils_1_1LoggerError}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1LoggerErrorCategory}{hyperion\+::utils\+::\+Logger\+Error\+Category}} \\*{\ttfamily std\+::error\+\_\+category} type for {\ttfamily Log\+Error\+Type}s. Provides error catgory functionality for {\ttfamily Log\+Error\+Type}s }{\pageref{structhyperion_1_1utils_1_1LoggerErrorCategory}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1LoggerInitError}{hyperion\+::utils\+::\+Logger\+Init\+Error}} }{\pageref{classhyperion_1_1utils_1_1LoggerInitError}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1NoneType}{hyperion\+::utils\+::\+None\+Type}} }{\pageref{structhyperion_1_1utils_1_1NoneType}}{}
\item\contentsline{section}{\mbox{\hyperlink{structhyperion_1_1utils_1_1OkWrapper}{hyperion\+::utils\+::\+Ok\+Wrapper$<$ T $>$}} }{\pageref{structhyperion_1_1utils_1_1OkWrapper}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Option}{hyperion\+::utils\+::\+Option$<$ T $>$}} \\*Represents an optional value. Every {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1Option}{Option}}} is either {\ttfamily Some} and contains a value, or {\ttfamily None}, and does not. Useful for things such as\+: }{\pageref{classhyperion_1_1utils_1_1Option}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Result}{hyperion\+::utils\+::\+Result$<$ T, E $>$}} \\*Represents the result of an operation that can fail. Every {\ttfamily Result()} is either {\ttfamily Ok}, indicating success and containing a value or {\ttfamily Err}, indicating failure and containing an {\ttfamily \mbox{\hyperlink{classhyperion_1_1utils_1_1Error}{Error}}} type }{\pageref{classhyperion_1_1utils_1_1Result}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Thread\+Safety, Allocator $>$}} \\*A simple Ring Buffer implementation. Supports resizing, writing, reading, erasing, and provides mutable and immutable random access iterators }{\pageref{classhyperion_1_1utils_1_1RingBuffer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4}{hyperion\+::utils\+::\+Ring\+Buffer$<$ T, Ring\+Buffer\+Type\+::\+Thread\+Safe, Allocator $>$}} \\*A simple Ring Buffer implementation. Supports resizing, writing, reading, erasing, and provides mutable and immutable random access iterators }{\pageref{classhyperion_1_1utils_1_1RingBuffer_3_01T_00_01RingBufferType_1_1ThreadSafe_00_01Allocator_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Span}{hyperion\+::utils\+::\+Span$<$ T, Size $>$}} \\*Thin wrapper around {\ttfamily gsl\+::span} }{\pageref{classhyperion_1_1utils_1_1Span}}{}
\item\contentsline{section}{\mbox{\hyperlink{classhyperion_1_1utils_1_1Variant}{hyperion\+::utils\+::\+Variant$<$ Types $>$}} }{\pageref{classhyperion_1_1utils_1_1Variant}}{}
\end{DoxyCompactList}
