<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.18">
  <compounddef id="classhyperion_1_1utils_1_1Option" kind="class" language="C++" prot="public">
    <compoundname>hyperion::utils::Option</compoundname>
    <includes refid="OptionAndResult_8h" local="no">OptionAndResult.h</includes>
    <templateparamlist>
      <param>
        <type>Passable</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
    </templateparamlist>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classhyperion_1_1utils_1_1Option_1a0401ecb014bfa8f21524b86765712d9c" prot="private" static="no" mutable="no">
        <type>T</type>
        <definition>T hyperion::utils::Option&lt; T &gt;::m_some</definition>
        <argsstring></argsstring>
        <name>m_some</name>
        <briefdescription>
<para>The contained value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="674" column="3" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="674" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classhyperion_1_1utils_1_1Option_1a398882109e7012e04b23614d58ec0e20" prot="private" static="no" mutable="no">
        <type>bool</type>
        <definition>bool hyperion::utils::Option&lt; T &gt;::m_is_some</definition>
        <argsstring></argsstring>
        <name>m_is_some</name>
        <initializer>= false</initializer>
        <briefdescription>
<para>Whether this is <computeroutput>Some</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="676" column="6" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="676" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a54a8cfccd966a3ea5385ff3cd461d88a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>(NoneType none) noexcept</argsstring>
        <name>Option</name>
        <param>
          <type><ref refid="structhyperion_1_1utils_1_1NoneType" kindref="compound">NoneType</ref></type>
          <declname>none</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="65" column="11" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="65" bodyend="67"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1aa0c927b8b6bad13ced95ccb796d7e7c2" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>(const Option &amp;option) noexcept requires Copyable&lt; T &gt;=default</argsstring>
        <name>Option</name>
        <param>
          <type>const <ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref> &amp;</type>
          <declname>option</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="68" column="11"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1abc841b9bb059e54792212a080b47b990" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>(Option &amp;&amp;option) noexcept requires Movable&lt; T &gt;</argsstring>
        <name>Option</name>
        <param>
          <type><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref> &amp;&amp;</type>
          <declname>option</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="70" column="11" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="70" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ae3ede3d09468985054f1264b97c25efd" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>hyperion::utils::Option&lt; T &gt;::~Option</definition>
        <argsstring>() noexcept=default</argsstring>
        <name>~Option</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="83" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a5d7022c6108b2236eb076e28f51de1ec" prot="public" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::is_some</definition>
        <argsstring>() const noexcept -&gt; bool</argsstring>
        <name>is_some</name>
        <briefdescription>
<para>Returns <computeroutput>true</computeroutput> if this is <computeroutput>Some</computeroutput>, <computeroutput>false</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Whether this is <computeroutput>Some</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="115" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="115" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a7600cdffac19e50db81c6df72e38da14" prot="public" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::is_none</definition>
        <argsstring>() const noexcept -&gt; bool</argsstring>
        <name>is_none</name>
        <briefdescription>
<para>Returns <computeroutput>true</computeroutput> if this is <computeroutput>None</computeroutput>, <computeroutput>false</computeroutput> if this is <computeroutput>Some</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Whether this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="122" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="122" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ac5f993a8b77adb1aade9aa5796f29c8d" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map</definition>
        <argsstring>(std::function&lt; U(const T &amp;)&gt; map_func) const noexcept -&gt; Option&lt; U &gt; requires NotPointer&lt; T &gt;</argsstring>
        <name>map</name>
        <param>
          <type>std::function&lt; U(const T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;U&gt;</computeroutput>, returning <computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="135" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="135" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a5a72d53a98236b4fdd018008b26acd8e" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map</definition>
        <argsstring>(std::function&lt; U(const T)&gt; map_func) const noexcept -&gt; Option&lt; U &gt; requires Pointer&lt; T &gt;</argsstring>
        <name>map</name>
        <param>
          <type>std::function&lt; U(const T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;U&gt;</computeroutput>, returning <computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="154" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="154" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1afb037d4cb8c7eafa5a08c498ebad575a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map</definition>
        <argsstring>(std::function&lt; U(T &amp;)&gt; map_func) noexcept -&gt; Option&lt; U &gt; requires NotPointer&lt; T &gt;</argsstring>
        <name>map</name>
        <param>
          <type>std::function&lt; U(T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;U&gt;</computeroutput>, returning <computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="172" column="14" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="172" bodyend="180"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a7176eba544b26237b4d2bb798f5bf6cf" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map</definition>
        <argsstring>(std::function&lt; U(T)&gt; map_func) noexcept -&gt; Option&lt; U &gt; requires Pointer&lt; T &gt;</argsstring>
        <name>map</name>
        <param>
          <type>std::function&lt; U(T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;U&gt;</computeroutput>, returning <computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(U)</computeroutput> if this is Some, or <computeroutput>None</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="190" column="14" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="190" bodyend="198"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a1435d40724461c4f55831b9ad8325deb" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(const T &amp;)&gt; map_func, const U &amp;default_value) const noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(const T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="211" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="211" bodyend="219"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1af6565ecc6477bfcc18546029e6075a3a" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(const T)&gt; map_func, const U &amp;default_value) const noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(const T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="232" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="232" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1aeecbf3e09f9abcbc73082fdcb66f6f95" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(const T &amp;)&gt; map_func, U &amp;&amp;default_value) const noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(const T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>U &amp;&amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="253" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="253" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a14b3b4e0567852da6214260e8155a394" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(const T)&gt; map_func, U &amp;&amp;default_value) const noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(const T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>U &amp;&amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="274" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="274" bodyend="282"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ac318c44d9a549c883c97e7f5869956f5" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(T &amp;)&gt; map_func, const U &amp;default_value) noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="295" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="295" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a11d1e668d546f5513866d308a44dcecb" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(T)&gt; map_func, const U &amp;default_value) noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>const U &amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="316" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="316" bodyend="324"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1aa3f0c9101793f10dec3bf5e6f0e2100a" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(T &amp;)&gt; map_func, U &amp;&amp;default_value) noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>U &amp;&amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="336" column="14" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="336" bodyend="344"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a825b7cacb3ab884c7b3713e2658d5edc" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or</definition>
        <argsstring>(std::function&lt; U(T)&gt; map_func, U &amp;&amp;default_value) noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or</name>
        <param>
          <type>std::function&lt; U(T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>U &amp;&amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="357" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="357" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a1cbb0b83a15f45ddb6c5a0a31e12e27d" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or_else</definition>
        <argsstring>(std::function&lt; U(const T &amp;)&gt; map_func, std::function&lt; U()&gt; default_generator) const noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or_else</name>
        <param>
          <type>std::function&lt; U(const T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>std::function&lt; U()&gt;</type>
          <declname>default_generator</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>U</computeroutput> (the default value returned by <computeroutput>default_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or the value returned by <computeroutput>default_generator</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="379" column="14" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="379" bodyend="388"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ade4e38a3fab6307978c44761b2854901" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or_else</definition>
        <argsstring>(std::function&lt; U(const T)&gt; map_func, std::function&lt; U()&gt; default_generator) const noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or_else</name>
        <param>
          <type>std::function&lt; U(const T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>std::function&lt; U()&gt;</type>
          <declname>default_generator</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>U</computeroutput> (the default value returned by <computeroutput>default_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or the value returned by <computeroutput>default_generator</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="404" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="404" bodyend="412"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1afef9a853ff7726c0152cb3d381a12631" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or_else</definition>
        <argsstring>(std::function&lt; U(T &amp;)&gt; map_func, std::function&lt; U()&gt; default_generator) noexcept -&gt; U requires NotPointer&lt; T &gt;</argsstring>
        <name>map_or_else</name>
        <param>
          <type>std::function&lt; U(T &amp;)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>std::function&lt; U()&gt;</type>
          <declname>default_generator</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>U</computeroutput> (the default value returned by <computeroutput>default_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or the value returned by <computeroutput>default_generator</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="428" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="428" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1aded464a18aa455f49fb1ecc000ddd359" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>Passable</type>
            <declname>U</declname>
            <defname>U</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::map_or_else</definition>
        <argsstring>(std::function&lt; U(T)&gt; map_func, std::function&lt; U()&gt; default_generator) noexcept -&gt; U requires Pointer&lt; T &gt;</argsstring>
        <name>map_or_else</name>
        <param>
          <type>std::function&lt; U(T)&gt;</type>
          <declname>map_func</declname>
        </param>
        <param>
          <type>std::function&lt; U()&gt;</type>
          <declname>default_generator</declname>
        </param>
        <briefdescription>
<para>Maps this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>U</computeroutput>, returning <computeroutput>U</computeroutput> (mapped by <computeroutput>map_func</computeroutput>) if this is <computeroutput>Some</computeroutput>, or <computeroutput>U</computeroutput> (the default value returned by <computeroutput>default_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to map to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>map_func</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to perform the mapping </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>default_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the default value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result of the mapping if this is <computeroutput>Some</computeroutput>, or the value returned by <computeroutput>default_generator</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="452" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="452" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ab3984b5aa618bebb80b2717b8e60d6fd" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>requires constexpr NotReference&lt; T &gt; auto hyperion::utils::Option&lt; T &gt;::ok_or</definition>
        <argsstring>(const ErrorType auto &amp;error) noexcept -&gt; Result&lt; T, decltype(error)&gt; requires NotReference&lt; std::remove_reference_t&lt; decltype(error)&gt;&gt;</argsstring>
        <name>ok_or</name>
        <param>
          <type>const ErrorType auto &amp;</type>
          <declname>error</declname>
        </param>
        <briefdescription>
<para>Converts this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>Result()</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>. Returns <computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput> or <computeroutput>Err(error)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to return if this is <computeroutput>None</computeroutput>. Must be an <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> type (<computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">hyperion::utils::Error</ref></computeroutput>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>error</parametername>
</parameternamelist>
<parameterdescription>
<para>- The <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> to return if this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> is <computeroutput>None</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, <computeroutput>Err(error)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="472" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="1852" bodyend="1860"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a7143c01c612dc55a1ab6d958d6dc9ee5" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>requires constexpr NotReference&lt; T &gt; auto hyperion::utils::Option&lt; T &gt;::ok_or</definition>
        <argsstring>(ErrorType auto &amp;&amp;error) noexcept -&gt; Result&lt; T, std::remove_reference_t&lt; decltype(error)&gt;&gt;</argsstring>
        <name>ok_or</name>
        <param>
          <type>ErrorType auto &amp;&amp;</type>
          <declname>error</declname>
        </param>
        <briefdescription>
<para>Converts this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>Result()</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>. Returns <computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput> or <computeroutput>Err(error)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to return if this is <computeroutput>None</computeroutput>. Must be an <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> type (<computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">hyperion::utils::Error</ref></computeroutput>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>error</parametername>
</parameternamelist>
<parameterdescription>
<para>- The <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> to return if this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> is <computeroutput>None</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, <computeroutput>Err(error)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="484" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="1873" bodyend="1882"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a6f5a2fc155f9e00fa536c4a10b07e475" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>ErrorType</type>
            <declname>E</declname>
            <defname>E</defname>
            <defval><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></defval>
          </param>
        </templateparamlist>
        <type>requires NotReference&lt; E &gt; auto</type>
        <definition>requires NotReference&lt;E&gt; auto hyperion::utils::Option&lt; T &gt;::ok_or_else</definition>
        <argsstring>(std::function&lt; E()&gt; error_generator) noexcept -&gt; Result&lt; T, E &gt;</argsstring>
        <name>ok_or_else</name>
        <param>
          <type>std::function&lt; E()&gt;</type>
          <declname>error_generator</declname>
        </param>
        <briefdescription>
<para>Converts this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>Result()&lt;T, E&gt;</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>. Returns <computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, or <computeroutput>Err(E)</computeroutput> (where E is generated by <computeroutput>error_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to return if this is <computeroutput>None</computeroutput>. Must be an <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> type (<computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">hyperion::utils::Error</ref></computeroutput>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>error_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, <computeroutput>Err(E)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="499" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a61b04ab6b17f4fd2483d123cc73b13ce" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::unwrap</definition>
        <argsstring>() noexcept -&gt; T requires Movable&lt; T &gt; &amp;&amp;NotPointer&lt; T &gt;</argsstring>
        <name>unwrap</name>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. If this is not <computeroutput>Some</computeroutput>, then <computeroutput>std::terminate</computeroutput> is called. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="506" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="506" bodyend="516"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a2fdacb103fb631083c2b1dda6205d02a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::unwrap</definition>
        <argsstring>() noexcept -&gt; T requires Pointer&lt; T &gt;</argsstring>
        <name>unwrap</name>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. If this is not <computeroutput>Some</computeroutput>, then <computeroutput>std::terminate</computeroutput> is called. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="522" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="522" bodyend="533"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a82a3c5e348c004e1cae580dda37ae461" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::unwrap</definition>
        <argsstring>() noexcept -&gt; T requires NotMovable&lt; T &gt; &amp;&amp;NotPointer&lt; T &gt;</argsstring>
        <name>unwrap</name>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. If this is not <computeroutput>Some</computeroutput>, then <computeroutput>std::terminate</computeroutput> is called. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="540" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="540" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1aaec935992dd09195d28751289b80bd69" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::unwrap_or</definition>
        <argsstring>(const T &amp;default_value) noexcept -&gt; T</argsstring>
        <name>unwrap_or</name>
        <param>
          <type>const T &amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. If this is not <computeroutput>Some</computeroutput>, then returns <computeroutput>default_value</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The value to return if this is <computeroutput>None</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="558" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="558" bodyend="565"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a909d94716b23a9a14600d01832ea255e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::unwrap_or</definition>
        <argsstring>(T &amp;&amp;default_value) noexcept -&gt; T</argsstring>
        <name>unwrap_or</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>default_value</declname>
        </param>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. If this is not <computeroutput>Some</computeroutput>, then returns <computeroutput>default_value</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>default_value</parametername>
</parameternamelist>
<parameterdescription>
<para>- The value to return if this is <computeroutput>None</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, or <computeroutput>default_value</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="573" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="573" bodyend="580"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a62498580976bc955afda70ece82b68e1" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>auto</type>
        <definition>auto hyperion::utils::Option&lt; T &gt;::unwrap_or_else</definition>
        <argsstring>(std::function&lt; T()&gt; default_generator) noexcept -&gt; T</argsstring>
        <name>unwrap_or_else</name>
        <param>
          <type>std::function&lt; T()&gt;</type>
          <declname>default_generator</declname>
        </param>
        <briefdescription>
<para>Returns the contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>. If this is not <computeroutput>Some</computeroutput>, then returns the value generated by <computeroutput>default_generator</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>default_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the value returned if this is <computeroutput>None</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The contained <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, or the value generated by <computeroutput>default_generator</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="592" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="592" bodyend="599"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ab3c745a8d3c9f24fbe538eae324412e9" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::get_mut</definition>
        <argsstring>() noexcept</argsstring>
        <name>get_mut</name>
        <briefdescription>
<para>Similar to <computeroutput>unwrap</computeroutput>, except doesn&apos;t consume this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. Returns a pointer to the mutable <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, otherwise calls <computeroutput>std::terminate</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A pointer (or reference if <computeroutput>T</computeroutput> is a reference) to <computeroutput>T</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="606" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="606" bodyend="619"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a24246c2da075f10ee5fa49699796e108" prot="public" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::get_const</definition>
        <argsstring>() const noexcept</argsstring>
        <name>get_const</name>
        <briefdescription>
<para>Similar to <computeroutput>unwrap</computeroutput>, except doesn&apos;t consume this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput>. Returns a pointer to the const <computeroutput>T</computeroutput> if this is <computeroutput>Some</computeroutput>, otherwise calls <computeroutput>std::terminate</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A pointer (or reference if <computeroutput>T</computeroutput> is a reference) to const <computeroutput>T</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="626" column="24" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="626" bodyend="639"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a813df19da0e32101f4cc859756e25b07" prot="public" static="no" constexpr="yes" const="yes" explicit="yes" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::operator bool</definition>
        <argsstring>() const noexcept</argsstring>
        <name>operator bool</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="641" column="20" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="641" bodyend="643"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a3d7577dfef5c044bbfa57184a337ab24" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::operator=</definition>
        <argsstring>(const Option &amp;option) -&gt; Option &amp;requires Copyable&lt; T &gt;=default</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref> &amp;</type>
          <declname>option</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="645" column="16"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1adc3d1fb4ec3f14cff5f5b764422253cd" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr auto</type>
        <definition>constexpr auto hyperion::utils::Option&lt; T &gt;::operator=</definition>
        <argsstring>(Option &amp;&amp;option) noexcept -&gt; Option &amp;requires Movable&lt; T &gt;</argsstring>
        <name>operator=</name>
        <param>
          <type><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref> &amp;&amp;</type>
          <declname>option</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="647" column="16" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="647" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a201f9ef41a5675b40694aeba23ea74bc" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>ErrorType</type>
            <declname>E</declname>
            <defname>E</defname>
          </param>
        </templateparamlist>
        <type>requires NotReference&lt; T &gt; requires NotReference&lt; E &gt; auto</type>
        <definition>requires NotReference&lt;T&gt; requires NotReference&lt;E&gt; auto hyperion::utils::Option&lt; T &gt;::ok_or_else</definition>
        <argsstring>(std::function&lt; E()&gt; error_generator) noexcept -&gt; Result&lt; T, E &gt;</argsstring>
        <name>ok_or_else</name>
        <param>
          <type>std::function&lt; E()&gt;</type>
          <declname>error_generator</declname>
        </param>
        <briefdescription>
<para>Converts this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> to a <computeroutput>Result()&lt;T, E&gt;</computeroutput>, consuming this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>. Returns <computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, or <computeroutput>Err(E)</computeroutput> (where E is generated by <computeroutput>error_generator</computeroutput>) if this is <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type to return if this is <computeroutput>None</computeroutput>. Must be an <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> type (<computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">hyperion::utils::Error</ref></computeroutput>) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>error_generator</parametername>
</parameternamelist>
<parameterdescription>
<para>- The function to generate the <computeroutput><ref refid="classhyperion_1_1utils_1_1Error" kindref="compound">Error</ref></computeroutput> value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Ok(T)</computeroutput> if this is <computeroutput>Some</computeroutput>, <computeroutput>Err(E)</computeroutput> if this is <computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="1898" column="8" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="1898" bodyend="1905"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1abe85f4e95805830cff7726191c99bbba" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr static auto</type>
        <definition>constexpr static auto hyperion::utils::Option&lt; T &gt;::Some</definition>
        <argsstring>(const T &amp;some) noexcept -&gt; Option</argsstring>
        <name>Some</name>
        <param>
          <type>const T &amp;</type>
          <declname>some</declname>
        </param>
        <briefdescription>
<para>Constructs an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> containing <computeroutput>some</computeroutput>, aka a <computeroutput>Some</computeroutput> variant containing <computeroutput>some</computeroutput> aka <computeroutput>Some(some)</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>some</parametername>
</parameternamelist>
<parameterdescription>
<para>- The value to store in this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(some)</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="91" column="31" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="91" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a72ef6028e8f0447a359806a6463d27dc" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr static auto</type>
        <definition>constexpr static auto hyperion::utils::Option&lt; T &gt;::Some</definition>
        <argsstring>(T &amp;&amp;some) noexcept -&gt; Option</argsstring>
        <name>Some</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>some</declname>
        </param>
        <briefdescription>
<para>Constructs an <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput> containing <computeroutput>some</computeroutput>, aka a <computeroutput>Some</computeroutput> variant containing <computeroutput>some</computeroutput> aka <computeroutput>Some(some)</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>some</parametername>
</parameternamelist>
<parameterdescription>
<para>- The value to store in this <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>Some(some)</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="101" column="31" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="101" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1ae43444cc63daa5ad6aa3f2fb2cd68f8a" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr static auto</type>
        <definition>constexpr static auto hyperion::utils::Option&lt; T &gt;::None</definition>
        <argsstring>(NoneType none) noexcept -&gt; Option</argsstring>
        <name>None</name>
        <param>
          <type><ref refid="structhyperion_1_1utils_1_1NoneType" kindref="compound">NoneType</ref></type>
          <declname>none</declname>
        </param>
        <briefdescription>
<para>Constructs an empty <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref>&lt;T&gt;</computeroutput>, aka a <computeroutput>None</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para><computeroutput>None</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="108" column="31" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="108" bodyend="110"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a54613af3618f3fc6754fb2b87e6676f8" prot="private" static="no" constexpr="yes" const="no" explicit="yes" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>(const T &amp;some) noexcept requires Movable&lt; T &gt;</argsstring>
        <name>Option</name>
        <param>
          <type>const T &amp;</type>
          <declname>some</declname>
        </param>
        <briefdescription>
<para>value type constructor </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="663" column="22" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="663" bodyend="665"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a65ac7eb30930ca4e717e7244aeb581fe" prot="private" static="no" constexpr="yes" const="no" explicit="yes" inline="yes" noexcept="yes" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>(T &amp;&amp;some) noexcept</argsstring>
        <name>Option</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>some</declname>
        </param>
        <briefdescription>
<para>rvalue constructor </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="668" column="20" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="668" bodyend="669"/>
      </memberdef>
      <memberdef kind="function" id="classhyperion_1_1utils_1_1Option_1a51753e245b08c095aa5da6cbe95ca107" prot="private" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr</type>
        <definition>constexpr hyperion::utils::Option&lt; T &gt;::Option</definition>
        <argsstring>()=default</argsstring>
        <name>Option</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="671" column="11"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Represents an optional value. Every <computeroutput><ref refid="classhyperion_1_1utils_1_1Option" kindref="compound">Option</ref></computeroutput> is either <computeroutput>Some</computeroutput> and contains a value, or <computeroutput>None</computeroutput>, and does not. Useful for things such as: </para>
    </briefdescription>
    <detaileddescription>
<para><itemizedlist>
<listitem><para>* Optional members/fields</para>
</listitem><listitem><para>* Members/fields that can be loaned or &quot;taken&quot;</para>
</listitem><listitem><para>* Optional function arguments</para>
</listitem><listitem><para>* Nullable types/pointers</para>
</listitem><listitem><para>* Return values for functions not defined over their entire input range</para>
</listitem></itemizedlist>
</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>- The type of the potentially-contained value </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <location file="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" line="63" column="1" bodyfile="/home/braxton/git/Hyperion/utils/include/HyperionUtils/OptionAndResult.h" bodystart="63" bodyend="679"/>
    <listofallmembers>
      <member refid="classhyperion_1_1utils_1_1Option_1a24246c2da075f10ee5fa49699796e108" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>get_const</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ab3c745a8d3c9f24fbe538eae324412e9" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>get_mut</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a7600cdffac19e50db81c6df72e38da14" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>is_none</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a5d7022c6108b2236eb076e28f51de1ec" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>is_some</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a398882109e7012e04b23614d58ec0e20" prot="private" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>m_is_some</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a0401ecb014bfa8f21524b86765712d9c" prot="private" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>m_some</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ac5f993a8b77adb1aade9aa5796f29c8d" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a5a72d53a98236b4fdd018008b26acd8e" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1afb037d4cb8c7eafa5a08c498ebad575a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a7176eba544b26237b4d2bb798f5bf6cf" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a1435d40724461c4f55831b9ad8325deb" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1af6565ecc6477bfcc18546029e6075a3a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1aeecbf3e09f9abcbc73082fdcb66f6f95" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a14b3b4e0567852da6214260e8155a394" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ac318c44d9a549c883c97e7f5869956f5" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a11d1e668d546f5513866d308a44dcecb" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1aa3f0c9101793f10dec3bf5e6f0e2100a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a825b7cacb3ab884c7b3713e2658d5edc" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a1cbb0b83a15f45ddb6c5a0a31e12e27d" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ade4e38a3fab6307978c44761b2854901" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1afef9a853ff7726c0152cb3d381a12631" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1aded464a18aa455f49fb1ecc000ddd359" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>map_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ae43444cc63daa5ad6aa3f2fb2cd68f8a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>None</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ab3984b5aa618bebb80b2717b8e60d6fd" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>ok_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a7143c01c612dc55a1ab6d958d6dc9ee5" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>ok_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a6f5a2fc155f9e00fa536c4a10b07e475" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>ok_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a201f9ef41a5675b40694aeba23ea74bc" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>ok_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a813df19da0e32101f4cc859756e25b07" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>operator bool</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a3d7577dfef5c044bbfa57184a337ab24" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>operator=</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1adc3d1fb4ec3f14cff5f5b764422253cd" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>operator=</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a54a8cfccd966a3ea5385ff3cd461d88a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1aa0c927b8b6bad13ced95ccb796d7e7c2" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1abc841b9bb059e54792212a080b47b990" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a54613af3618f3fc6754fb2b87e6676f8" prot="private" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a65ac7eb30930ca4e717e7244aeb581fe" prot="private" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a51753e245b08c095aa5da6cbe95ca107" prot="private" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Option</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1abe85f4e95805830cff7726191c99bbba" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Some</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a72ef6028e8f0447a359806a6463d27dc" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>Some</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a61b04ab6b17f4fd2483d123cc73b13ce" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a2fdacb103fb631083c2b1dda6205d02a" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a82a3c5e348c004e1cae580dda37ae461" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1aaec935992dd09195d28751289b80bd69" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a909d94716b23a9a14600d01832ea255e" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap_or</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1a62498580976bc955afda70ece82b68e1" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>unwrap_or_else</name></member>
      <member refid="classhyperion_1_1utils_1_1Option_1ae3ede3d09468985054f1264b97c25efd" prot="public" virt="non-virtual"><scope>hyperion::utils::Option</scope><name>~Option</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
